贪心专题：
在某一个标准下，优先考虑最满足标准的样本，最后考虑不满足标准的样本，最终得到一个答案的方法，称为贪心算法。
也就是说，不从整体最优考虑，所作出的某种意义上的局部最优解
局部最优 到 整体最优 （很难证明，不掌握证明，而是掌握套路）

贪心算法的在笔试时的解题套路
1，实现一个不依靠贪心策略的解法X，可以用最暴力的尝试
2，脑补出贪心策略A、贪心策略B、贪心策略C...
3，用解法X和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确
4，不要去纠结贪心策略的证明

训练思路：高中数学式学法，尽可能多讲解一些常出现的经典例题，熟练掌握即可。然后碰到一个新的就掌握一个新的，积累。
以下列举贪心算法的经典例题：（常出现的例题，熟练掌握思路）
例1 会议问题。一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。
给你每一个项目开始的时间和结束的时间(给你一个数组，里面是一个个具体的项目的开始时间和结束时间)，
你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。请返回这个最多的宣讲场次。、

假设有这几个会议：[7,18],[8,9],[9,10],[15,17]
策略1 按会议开始时间早来安排，不能得到全局最优解
策略2 按项目持续时间短来安排，不能得到全局最优解
策略3 按哪个会议结束时间早先安排谁，然后把这之后不能安排的回忆删掉，再继续找到结束时间早的会议安排，以此得到全局最优解


例2 给定一个字符串类型的数组strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的字符串具有最小的字典序。

例如：["bk","at","cs"]
策略1 先把数组中的字符串按字典序排序，再拼接。显然不对：["at","bk","cs"] =》 atbkcs
看似是对额度，其实不一定每次都能得到字典序最小的。 举反例，如["b","ba"],先对每个字符串按字典序排序,得到["b","ba"]
拼接得到"bba" 但是其实bab才是所有字符串拼起来之后形成的最小的字典序
策略2 假设字符串数组中有 a b两个元素，根据a.b <= b.a（a作为前缀拼接b是否字典序小于等于b作为前缀拼接a）的策略来排序


例3 一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管切成长度多大的两半，都要花费20个铜板。
一群人想整分整块金条，怎么分最省铜板? 例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为10+20+30=60。
金条要分成10,20,30三个部分。 如果先把长度60的金条分成10和50，花费60; 再把长度50的金条分成20和30，花费50;
一共花费110铜板。
但是如果先把长度60的金条分成30和30，花费60;再把长度30金条分成10和20， 花费30;一共花费90铜板。
输入一个数组，返回分割的最小代价。

策略思路：构造一个小根堆，然后玩构造哈夫曼树的过程：先从小根堆弹出两个元素相加然后放回小根堆，重复操作直到小根堆里只有
一个元素，然后前面这些所有结果的累加和就是最小代价。


例4 输入:
   正数数组costs
   正数数组profits
   正数k
   正数m
   含义:costs[i]表示i号项目的花费 profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)，
   k表示你只能串行的最多做k个项目
   m表示你初始的资金
   说明: 你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。项目不可以重复做。
   输出: 你最后获得的最大钱数。

